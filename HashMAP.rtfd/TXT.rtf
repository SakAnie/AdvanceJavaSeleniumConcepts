{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Georgia;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Georgia-Bold;
\f3\fnil\fcharset0 Menlo-Bold;\f4\fnil\fcharset0 Menlo-BoldItalic;\f5\fswiss\fcharset0 ArialRoundedMTBold;
}
{\colortbl;\red255\green255\blue255;\red106\green62\blue62;\red251\green2\blue7;\red0\green0\blue0;
\red128\green0\blue128;\red251\green2\blue7;\red127\green0\blue128;\red63\green127\blue95;\red127\green0\blue85;
\red42\green0\blue255;\red0\green0\blue192;}
{\*\expandedcolortbl;;\csgenericrgb\c41569\c24314\c24314;\cssrgb\c100000\c14913\c0;\cssrgb\c0\c0\c0;
\cssrgb\c57919\c12801\c57269;\cssrgb\c100000\c14913\c0;\cssrgb\c57919\c12801\c57269;\csgenericrgb\c24706\c49804\c37255;\csgenericrgb\c49804\c0\c33333;
\csgenericrgb\c16471\c0\c100000;\csgenericrgb\c0\c0\c75294;}
\paperw11900\paperh16840\margl1011\margr1011\margb1445\margt1011\vieww14000\viewh16000\viewkind1\viewscale220
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f0\fs24 \cf0 PROGRAM3: HASHMAP<K,V>\
=======================\
\pard\pardeftab720\partightenfactor0

\f1 \cf3 \{6=forth, 5=fifth, 4=forth, 3=third, 2=second, 1=first\}
\f0 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\fs18 \cf0 HashMap<KeyDatatype,ValueDataType> hsObj=new HashMap<KeyDatatype,ValueDataTye>();\
\
The  KeyDatatype & ValueDataType can be Objects of some third class or PRIMITIVE JAVA CLASS objects (INTEGER,BOOLEAN,STRING<DOUBLE<CHARACTER)\
\
0)We can retrieve value of a HashMAP using \cf3 mapobj.get(\'93key\'94);\cf0 \
1)HashMap stores values in 
\f2\b \cf3 RANDOM FASHION (\cf4 NO ORDER \cf3 IS MAINTENAINED,\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf4 2)NOT THREAD SAFE-NOT SYNCHRONISED\cf3 \
3)\cf4 CAN BE NULL -\cf3 ONLY \cf4 ONE NULL KEY \cf3 IS ALLOWED IN HASHMAP,BUT \cf4 MULTIPLE NULL VALUES\cf3  ARE ALLOWED)\
4)
\f0\b0 \cf0 based on HASHING Technique. Thats why it is the only DS with Time Complexity
\f2\b \cf3  O(1) for insert , search,delete.
\f0\b0 \cf0 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf0 5)How does a HashMAP Looks?
\f0\b0 \
\pard\pardeftab720\partightenfactor0

\f1 \cf3       \{0=Zeroth value, 1=firstValue, 2=second value, 3=third value, 4=Forth value\}
\f0 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 \
6)The \cf3 Key of a HashMap must be UNIQUE\cf0  , if we use same key for 2 values , then it will replace the other value but will not add the same key to the HashMap.\
\
\pard\pardeftab720\partightenfactor0

\f3\b \cf0 How HashTable works internally?\
================================
\f1\b0 \
\pard\pardeftab720\partightenfactor0
\cf5 Hashing? \cf0 \
Hashing is a function which produces HashCodes. \
\
\cf5 HashCode?\cf0  is the address of a element converted into Integer.\
=>Using Hashing a large number(HashCode) is converted into small number(index).\
\
\cf5 How index value to store the Key Node \{K,V,HashCode,Next\} is Calculated?\cf0 \
=>
\f3\b \cf6 Hash(\'93Key\'94)= HashCode .\
Now, HashCode % 11(default bucket size) ==>gives==>IndexNumber \
\
\

\f1\b0 \cf4 If 
\f3\b Hash(\'93Key1\'94)
\f1\b0  =  
\f3\b Hash(\'93Key2\'94)
\f1\b0 \
this means 
\f3\b HashCode Of Key1
\f1\b0  = 
\f3\b HashCode of Key2\

\f1\b0 this means 
\f3\b HashCode%11 (Key1)
\f1\b0 =
\f3\b HashCode%11 (Key2)
\f1\b0 \
this means 
\f3\b Index to store Key1
\f1\b0  node = 
\f3\b Index to store Key2
\f1\b0  node \
this means 
\f3\b \cf6 HASH COLLISION
\f1\b0 \cf0 \
\

\f3\b \cf6 How Hash Collision is handled?
\f1\b0 \cf0 \
Hash COLLISION is handled by Performing chain of Nodes \cf6 (Link List). O(len)\cf0 \
When Chain size > 8 then Link List becomes Self Balancing \cf6 Binary Search Tree. O(log(len))\
\cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic Screenshot 2022-03-04 at 10.02.07 PM.png \width25440 \height13180 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\
\pard\pardeftab720\partightenfactor0
\cf0 \
=>That Hash algorithm may vary (with the Data Type)\
\
=>The large number--> HashCode (address converted into integral format)\
\
Small number-->index where the Node is going to be saved
\f0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf0 \
7)How Does HashMAP works internally? (using HashTable)\
==========================================
\f0\b0 \

\f2\b What is HASHING? 
\f0\b0 \
\cf7 H(Key)====>HashCode . \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf7 For a specific  input , there will be a specific output only.
\f0\b0 \cf7 \
The function which converts it is called 
\f2\b \cf7 Hashing function. H()
\f0\b0 \cf7 \

\f2\b \cf7 HASHING
\f0\b0 \cf7 :converts a large number(address converted into int-->ie-->
\f2\b \cf7 HashCode)
\f0\b0 \cf7  into a smaller value 
\f2\b \cf7 (index Value)\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f0\b0 \cf0 Hashing function examples:\
1) For  Large integer Keys\
\
H()= Key%m;\
2)For Strings Keys\
H()=Weighted sum\
3)For Object Keys\
H()=Weighted sum of elements\
\
\

\f2\b Why it is called HASHMAP?
\f0\b0 \
\cf7 Because it used Hashing function to identify the index values of the <k,V> to be stored. And it maps Keys to Values , so Map.\cf0 \
\
\
Internally HashMap <k,v>, its Hash,its next node address is stored in the B\cf3 UCKETS of HashTable(LinkList).\cf0 \
Each bucket has 4 things :\cf3 [ HASHVALUE, KEY ,VALUE,ADDRESS_NEXT]\
\
Array of Nodes= HashTable\
Each node will be:-\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf4 Node\{\
int Hash;\
K Key;\
V Value;\
Node next;\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf3 \
When the insertion chain length becomes > 8 . O(1+length_pf_chain) ,then Java 8 converts them into Self Balancing Binary Search tree O(Length)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\pardirnatural\partightenfactor0
\cf3 {{\NeXTGraphic Screenshot 2022-03-03 at 8.54.53 PM.png \width6720 \height3560 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\pardirnatural\partightenfactor0
\cf4 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf4 \
Q>what is the requirement for the Key and the Object to be used in HashMap?\
\
Both K and V should implement  .equals() and hashCode() method\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf3 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf4 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic Screenshot 2022-03-03 at 8.52.15 PM.png \width28800 \height18000 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 \
HOW DOES 
\f2\b \cf3 HASH-MAP HANDLES
\f0\b0 \cf0  COLLISION IN JAVA?\
============================================\

\f2\b Default bucket size: 16 (HashMap) & 11 (HashTable)
\f0\b0 \
\

\f2\b VVI>For put method in HashMap,
\f0\b0 \
step1: HashCODE of KEY is calculated using some Hashing Algo . Example: 3432443\
Step2: %m will be used to reduce the size . 
\f2\b \cf3 HashCode(Key)%m= index_value\

\f0\b0 \cf0 step3: at this index position , the entire Node info(K,V,HashCode,Next) will be saved\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf3 When > 1 Key has the Same Index Value after Hashing , then the \'93Collision\'94 occurs.\
On the same index , multiple values are getting stored.\
\
Collision is handled by \'93\cf4 Linked List\'94  o(length)\cf3  but when no of nodes in the chain>\cf4 8 \cf3 then \cf4 \'93Self Balancing Binary Search Tree\'94. O(log(len))
\f0\b0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1 \cf8 		// 1. Initialisation of a HashMap
\f0 \cf0 \
\pard\pardeftab720\partightenfactor0

\f1 \cf0           HashMap<Integer, String> \cf2 hm\cf0  = 
\f3\b \cf9 new
\f1\b0 \cf0  HashMap<Integer, String>();\
\
		\cf8 // 1. INSERTION in HASHMAP put()\cf0 \
		\cf2 hm\cf0 .put(1, \cf10 "firstValue"\cf0 );\
		\cf2 hm\cf0 .put(0, \cf10 "Zeroth value"\cf0 );\
		\cf2 hm\cf0 .put(2, \cf10 "second value"\cf0 );\
		\cf2 hm\cf0 .put(3, \cf10 "third value"\cf0 );\
		\cf2 hm\cf0 .put(4, \cf10 "Forth value"\cf0 );\
\
		\cf8 // 2. Printing Elements of a HashMap\cf0 \
\
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 hm\cf0 ); \cf8 // >>>>>\{0=Zeroth value, 1=firstValue, 2=second value, 3=third value, 4=Forth\cf0 \
								\cf8 // value\}\cf0 \
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 hm\cf0 .values()); \cf8 // Values are printed as SET :>>>>[Zeroth value, firstValue, second value,\cf0 \
											\cf8 // third value, Forth value]\cf0 \
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 hm\cf0 .keySet());\cf8 // Keys are printed as SET >>>>>[0, 1, 2, 3, 4]\cf0 \
\
		\cf8 // 3. Accessing Value\cf0 \
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 hm\cf0 .get(3)); \cf8 // value at Index 3 . it will print NULL if index 3 doesn't exist in \ul hm\ulnone  as KEY.\cf0 \
\
		\cf8 // 4. Removing Values from HashMap at particular keys\cf0 \
		\cf2 hm\cf0 .remove(3);\
\
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 hm\cf0 .get(3));\
\
		\cf8 // 5. \cf3 VVI: 
\f3\b CONVERT HASHMAP TO SET _ \
\pard\pardeftab720\partightenfactor0

\f5\b0 \cf7 >>>>\cf4 STEP1: \cf3 HashMapObj.entrySet() call this method & assign it to the SET object\
\cf4 SET setObj=hasmapObj.entrySet();\cf3 \
\cf7 >>>>\cf4 STEP2:\cf3  Create the iterator class object  to iterate over the setObject using setObj.iterator();\
\cf4 Iterator it=setObj.iterator();\cf3 \
// Iterator will not have any DataType because the DataType of KEY and VALUE is \ul different\ulnone \
\
\cf7 >>>>\cf4 STEP3:\cf3 We create object Map.Entry Class by TypeCasting it.next() to (Map.Entry) 		\
\cf4 Map.Entry mpObj= (Map.Entry) it.next();\cf3 \
\
\cf7 >>>>\cf4 STEP4:\cf3 >>> Eventually this Map.Entry Class Object has methods called getKey() & getValue() which will separate the K & V of a MAP.\
\cf4 mp.getValue();\cf3 \
\cf4 mp.getKey();
\f3\b \cf3 \
\pard\pardeftab720\partightenfactor0

\f1\b0 \cf0 \
		\cf8 /*\cf0 \
\pard\pardeftab720\partightenfactor0
\cf8 		 * HASMAP: \{0=Zeroth value, 1=firstValue, 2=second value, 3=third value, 4=Forth\cf0 \
\cf8 		 * value\} SET_VERSION: [0=Zeroth value, 1=firstValue, 2=second value, 4=Forth\cf0 \
\cf8 		 * value]\cf0 \
\cf8 		 */\cf0 \
\
		\ul Set\ulnone  \cf2 setObject\cf0  = \cf2 hm\cf0 .entrySet();\
		System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 setObject\cf0 ); //
\f3\b \cf8 [0=Zeroth value, 1=firstValue, 2=second value, 4=Forth Value]\cf0 \

\f1\b0 \cf8 		\cf0 \
		\cf8 // Now , it has become a SET, so we can use 
\f3\b Iterator
\f1\b0 \cf0 \
		\ul Iterator\ulnone  \cf2 it\cf0  = \cf2 setObject\cf0 .iterator(); \
\
		
\f3\b \cf9 while
\f1\b0 \cf0  (\cf2 it\cf0 .hasNext()) \{\
\
			\ul Map.Entry\ulnone  \cf2 mp\cf0  = (\ul Map.Entry\ulnone ) \cf2 it\cf0 .next();\
			System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 mp\cf0 .getKey());\
			System.
\f4\i\b \cf11 out
\f1\i0\b0 \cf0 .println(\cf2 mp\cf0 .getValue());\
\
		\}
\f0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\fs24 \cf0 \
\

\f2\b HOW TO ADD ELEMENTS FROM ARRAY TO HASH-MAP?\
===========================================\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\fs18 \cf0 \

\f0\b0 \cf5 //Given, \cf0 \
String s=\'93 Hello my pretty lady\'94;\
HashMap<String,Integer> hm=HashMap<String,Integer>();\
\
\cf5 //Convert given string into Array. As per requirement.\cf0 \
A. to String[] array_s= s.split(\'93 \'93);\
B. to char[] array_c=s.toCharArray();\
\
\
\cf5 //Now iterate over each element of array using for each loop.\cf0 \
for(String x:array_s)\{\
\
if( hm.get(x)!=null)\{\
   \cf5 //if map already contains the element of the GivenArray as its key , then add it again and increment its count Value by 1\
\cf0 hm.put(x, hm.get(x) + 1);\
\}\
else\{\
\cf5 //if map does not contain the array element as its key then add it and make the count value as 1.\cf0 \
hm.put(x,1);\
\}\
\
\}/\cf5 /end of for each loop
\fs24 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf0 \

\f0\b0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\fi722\sl288\slmult1\pardirnatural\partightenfactor0

\f2\b \cf3 VVI:Method2 to iterate over Keys of  HashMAP:
\f0\b0 \cf0 \
===============================\
Iterator<KeyDataType> it=hm1.keySet().iterator();\
while(it.hasNext())\{\
KeyDataType tempKey=it.next();\
if(hm1.get(tempKey)>1)\{\
Syso( \'93Occurrence of\'94 +tempKey+ \'93is\'94+hm1.get(tempKey));\
\}\
\
\
\
\
\
---END OF HASHMAP-----Example in Codingquestions file-----\
}{\*\beandata789c9d935d6f82301486aff157748db752d876b12d8851c1c4cc2099b86497153a65e32ba5cef1ef57444aeb66b68c1bda73fabe4f7b4e6b8d3ed3047c105ac6793684a66e4040b2308fe26c3b84eb6036b88323bb675d39cb69f0e2bba048e292017f3d59cca7000e101a17454210720207f88bf92a00dc0321d78300ee182b1e103a1c0e3aae57e9619ed60b4be4d3bc2094550b6e36e0023d6211e498c65dd90e8f4671c8ec9e66bd93caee631aee62bec242f594474b46f9666d6ff5482a128d45fa146f75f9e68d84ac14324c29ae07c2a09fed934492692d573b3984092e855e4e37f9e9acbf9e3b5d5eb3e28c912da1f6ad85dae1518854636fa5f39fec2cf6a6502e603aceb5ca5140a8f36ca16715f93ff7e64fdc2eda567ce28ebd27f6ead6f78d778ef1e866cf48f9dcf4dfdba71ba591d2490dd334ee0df5c03ff68b5c3a9fb8360e57711aa6958c92572c8f8552b2dfead9d0329c1289f70b4354a4736bbc585e887b2a8a56cf2704670e665830cece7cde24513053ad540756ded6e9e109b6501bf52759b43a0b1d5facddfb02aa1d4161}